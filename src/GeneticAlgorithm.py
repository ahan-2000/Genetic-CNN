
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: nbs/GeneticAlgorithm.ipynb
import random
import numpy
from src import Train

class GA(object):
    def __init__(self,pop_size,gens,crossover_prob,mutation_prob):
        self.pop_size = pop_size
        self.gens = gens
        self.crossover_prob = crossover_prob
        self.mutation_prob = mutation_prob
        self.population_info = {}
        self.counter = 0
        self.init_counter = True

    def run(self,trainloader,validloader,epochs):
        population = self.initialize()
        print(f'Population {population}')
        count = 0
        gen_fitness = []
        train_info_grp = []
        while True:
            self.target = population[count]
            fits_population = [(self.fitness(chromo,trainloader,validloader,epochs)[0],chromo) for chromo in population]
            train_info = [self.fitness(chromo,trainloader,validloader,epochs)[1] for chromo in population]
            better_models = [self.fitness(chromo,trainloader,validloader,epochs)[2] for chromo in population]
            gen_fitness.append([f[0] for f in fits_population])
            train_info_grp.append(train_info)
            if self.verify(fits_population):
                break
            population = self.propagate(fits_populations)
            count += 1
            pass
        return population , train_info_grp , gen_fitness , better_models

    def propagate(self,fits_population):
        parent_gen = self.parents(fits_population)
        next_gen = []
        while len(nexts) < self.pop_size:
            parents = next(parent_generator)
            parent1 , parent2 = parents
            cross_bool = random.random() < self.crossover_prob
            daughters = self.uniform_crossover(parents) if cross else parents
            for daughter in daughters:
                mutate_bool = random.random() < self.mutation_prob
                next_gen.append(self.mutation(daughter) if mutate_bool else daughter)
                pass
            pass
            if self.init_parents:
                next_gen.append(parent1)
                next_gen.append(parent2)
                self.init_parents = False
        self.init_parents = True
        return nex_gen[:self.pop_size]
    pass

    def verify(self,fits_population):
        self.counter += 1
        print(f'Fitness and Population : {fits_population}')
        fits = [fit for fit,chromo in fits_population]
        best = max(fit)
        worst = min(fits)
        avg = sum(fits)/len(fits)
        print(f"[G{'%2d'%counter}] Score = [Best: {'%.4f'%best}, Avg: {'%.4f'%avg} , Worst: {'%.4f'%best}]")

        fits_population.sort(key=lambda tup : tup[0],reverse=True)
        best_fitness = fits_populations[0][0]
        best_chromosome = fits_populations[0][1]
        file = open('results/best_populations.txt','a+')
        file.write(f'{self.counter},{best_fitness},{best_chromosome}\n')
        file.close()

        return self.counter >= self.gens

    def generate_chromosome(self):
        incl_layers = random.sample(range(7,58),1)[0]
        freeze_layers = random.sample(range(0,18),1)[0]
        lr = random.sample(range(1,6),1)[0]
        drop_rate = random.sample(range(1,9),1)[0]
        chromosome = [incl_layers,freeze_layers,lr,drop_rate]
        return chromosome

    def initialize(self):
        return [self.generate_chromosome() for i in range(self.pop_size)]

    def fitness(self,chromosome,trainloader,validloader,epochs):
        path_img = '../images'
        weight_decay = 1e-4
        print(chromosome)
        incl_layers = chromosome[0]
        freeze_layers = chromosome[1]
        lr = 10**(-chromosome[2])
        drop_rate = chromosome[3]/10
        fitness = 0
        key = '-'.join(str(i) for i in chromosome)
        try:
            fitness = self.population_info[key]
        except:
            loss,train_info,model = Train.learner(trainloader,
                                  validloader,
                                  lr,
                                  weight_decay,
                                  incl_layers,
                                  freeze_layers,
                                  drop_rate,
                                  epochs)
            fitness = - loss
            self.population_info[key] = fitness
        return fitness , train_info ,model

    def parents(self,fits_population):
        while True:
            parent1 = self.tourn_selection(fits_population)
            parent2 = self.tourn_selection(fits_population)
            yield (parent1 , parent2)
            pass
        pass

    def twopoint_crossover(self,parents):
        parent1 , parent2 = parents
        idx1 = random.randint(1,len(self.target)-2)
        idx2 = random.randint(1,len(self.target)-2)
        if index1 > idx2: idx1 , idx2 = idx2 , idx1
        daughter1 = parent1[:idx1] + parent2[idx1:idx2] + parent1[idx2:]
        daughter2 = parent2[:idx1] + parent1[idx1:idx2] + parent2[idx2:]
        return (daughter1 , daughter2)

    def uniform_crossover(self,parents):
        parent1 , parent2 = parents
        daughter1 = []
        daughter2 = []
        for i in range(len(parent1)):
            prob = random.uniform(0,1.)
            if prob>0.5:
                daughter1.append(parent2[i])
                daughter2.append(parent1[i])
            else:
                daughter1.append(parent1[i])
                daughter2.append(parent2[i])
        return (daughter1,daughter2)

    def mutation(self,chromosome):
        mutated_chrom = chromosome
        for c in range(len(chromosome)):
            prob = random.uniform(0,1.)
            if prob > 0.5:
                # Inculded Layers
                if c == 0:
                    diff = random.randint(-5,5)
                    mutated_chromo[c] += diff
                    if mutated_chromo[c] > 58 or mutated_chromo[c] < 6:
                        mutated_chromo[c] -= diff
                # Freeze layers
                elif c == 1:
                    diff =  random.randint(-5,5)
                    prev_mutation = mutated_chromo[c]
                    mutated_chromo[c] += diff
                    if mutated_chromo[c] > mutated_chromo[0]:
                        mutated_chromo[c] = prev_mutation
                    if mutated_chromo[c] > 18:
                        mutated_chromo[c] = prev_mutation
                    if mutated_chromo[c] < 0:
                        mutated_chromo[c] = prev_mutation
                # learning rate
                elif c == 2:
                    diff = random.randint(-1,1)
                    mutated_chromo[c] += diff
                    if mutated_chromo[c] > 6 or mutated_chromo[c] < 1:
                        mutated_chromo[c] -= diff
                # Drop rate
                elif c == 3:
                    diff = random.randint(-1,1)
                    mutated_chromo[c] += diff
                    if mutated_chromo[c] > 5 or mutated_chromo[c] < 1:
                        mutated_chromo[c] -= diff
        return mutated_chromo

    def tourn_selection(self,fits_population):
        candidiate1_fit , candidiate1 = fits_population[random.randint(0,self.pop_size-1)]
        candidiate2_fit , candidiate2 = fits_population[random.randnt(0,self.pop_size-1)]
        return candidiate1 if candidiate1_fit > candidiate2_fit else candidiate2